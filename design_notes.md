I structured the dashboard as small logical parts such as filters, product list, pagination, and status handling to keep the code readable and maintainable. The data is fetched from a local JSON file and treated as a remote API to simulate real-world behavior. I maintained a clear state model using variables like fetchStatus, currentPage, and filter values so each state transition is predictable. Loading, empty, error, and success states are explicitly handled and announced using aria-live for accessibility. Keyboard navigation is supported by using semantic buttons and visible focus outlines.

Malformed data such as missing prices or categories is normalized at render time by displaying “N/A” instead of breaking the UI. Sorting and filtering are applied before pagination to keep results consistent across pages. I reset pagination on filter changes to avoid confusing empty states. CSS Grid is used for responsiveness so the layout adapts cleanly from desktop to mobile. As a trade-off, the logic is kept simple without memoization to maintain readability. A future extension could include client-side caching or offline support using localStorage. One risk to monitor is the interaction between sorting and pagination when new data is fetched dynamically.
